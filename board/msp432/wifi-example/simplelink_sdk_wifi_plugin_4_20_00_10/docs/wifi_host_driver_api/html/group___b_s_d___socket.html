<!-- HTML header for doxygen 1.8.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>SimpleLink CC3220/CC3120 Host Driver: BSD_Socket</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="slnavtree.css" rel="stylesheet" type="text/css"/>
<link href="sltabs.css" rel="stylesheet" type="text/css"/>
<link href="slgen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="4" cellpadding="4">
 <tbody>
 <tr>
  <td id="projectlogo"><img alt="Logo" src="ti_logo.png" height="50px" /></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">SimpleLink CC3220/CC3120 Host Driver
   &#160;<span id="projectnumber">Version&#160;2.0.1.15</span>
   </div>
   <div id="projectbrief">Simplifies the implementation of Internet connectivity</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group___b_s_d___socket.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">BSD_Socket</div>  </div>
</div><!--header-->
<div class="contents">

<p>Controls standard client/server sockets programming options and capabilities.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga636674bf9937205b85a797ee6077faa9"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structhostent.html">hostent</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___b_s_d___socket.html#ga636674bf9937205b85a797ee6077faa9">gethostbyname</a> (const char *name)</td></tr>
<tr class="memdesc:ga636674bf9937205b85a797ee6077faa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get host IP by name<br />
Obtain the IP Address of machine on network, by machine name.  <a href="#ga636674bf9937205b85a797ee6077faa9">More...</a><br /></td></tr>
<tr class="separator:ga636674bf9937205b85a797ee6077faa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3069f151a5fd4a29e3f0dafe7af43ea8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___b_s_d___socket.html#ga3069f151a5fd4a29e3f0dafe7af43ea8">socket</a> (int Domain, int Type, int Protocol)</td></tr>
<tr class="memdesc:ga3069f151a5fd4a29e3f0dafe7af43ea8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an endpoint for communication.  <a href="#ga3069f151a5fd4a29e3f0dafe7af43ea8">More...</a><br /></td></tr>
<tr class="separator:ga3069f151a5fd4a29e3f0dafe7af43ea8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9cd9fbec0dbb386f3ed5fce6c0bdb20a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___b_s_d___socket.html#ga9cd9fbec0dbb386f3ed5fce6c0bdb20a">accept</a> (int sd, sockaddr *addr, socklen_t *addrlen)</td></tr>
<tr class="memdesc:ga9cd9fbec0dbb386f3ed5fce6c0bdb20a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accept a connection on a socket.  <a href="#ga9cd9fbec0dbb386f3ed5fce6c0bdb20a">More...</a><br /></td></tr>
<tr class="separator:ga9cd9fbec0dbb386f3ed5fce6c0bdb20a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga203a2eda9a8c5a71d6056c67cae6aff5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___b_s_d___socket.html#ga203a2eda9a8c5a71d6056c67cae6aff5">bind</a> (int sd, const sockaddr *addr, socklen_t addrlen)</td></tr>
<tr class="memdesc:ga203a2eda9a8c5a71d6056c67cae6aff5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign a name to a socket.  <a href="#ga203a2eda9a8c5a71d6056c67cae6aff5">More...</a><br /></td></tr>
<tr class="separator:ga203a2eda9a8c5a71d6056c67cae6aff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0e1e895317be91692b6b8cc7e12b252"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___b_s_d___socket.html#gac0e1e895317be91692b6b8cc7e12b252">listen</a> (int sd, int backlog)</td></tr>
<tr class="memdesc:gac0e1e895317be91692b6b8cc7e12b252"><td class="mdescLeft">&#160;</td><td class="mdescRight">Listen for connections on a socket.  <a href="#gac0e1e895317be91692b6b8cc7e12b252">More...</a><br /></td></tr>
<tr class="separator:gac0e1e895317be91692b6b8cc7e12b252"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8548b5734b7684ed0a0f4b684ed726c9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___b_s_d___socket.html#ga8548b5734b7684ed0a0f4b684ed726c9">connect</a> (int sd, const sockaddr *addr, socklen_t addrlen)</td></tr>
<tr class="memdesc:ga8548b5734b7684ed0a0f4b684ed726c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initiate a connection on a socket.  <a href="#ga8548b5734b7684ed0a0f4b684ed726c9">More...</a><br /></td></tr>
<tr class="separator:ga8548b5734b7684ed0a0f4b684ed726c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6802e61923c5dc7fc6b317e250bebf2c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___b_s_d___socket.html#ga6802e61923c5dc7fc6b317e250bebf2c">select</a> (int nfds, fd_set *readsds, fd_set *writesds, fd_set *exceptsds, struct timeval *timeout)</td></tr>
<tr class="memdesc:ga6802e61923c5dc7fc6b317e250bebf2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Monitor socket activity.  <a href="#ga6802e61923c5dc7fc6b317e250bebf2c">More...</a><br /></td></tr>
<tr class="separator:ga6802e61923c5dc7fc6b317e250bebf2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaafa5721213ca1bfb2c1ab1ea0f39bf5c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___b_s_d___socket.html#gaafa5721213ca1bfb2c1ab1ea0f39bf5c">setsockopt</a> (int sd, int level, int optname, const void *optval, socklen_t optlen)</td></tr>
<tr class="memdesc:gaafa5721213ca1bfb2c1ab1ea0f39bf5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set socket options-.  <a href="#gaafa5721213ca1bfb2c1ab1ea0f39bf5c">More...</a><br /></td></tr>
<tr class="separator:gaafa5721213ca1bfb2c1ab1ea0f39bf5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37e0195dbaf69283dd8541c2ae631b82"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___b_s_d___socket.html#ga37e0195dbaf69283dd8541c2ae631b82">getsockopt</a> (int sd, int level, int optname, void *optval, socklen_t *optlen)</td></tr>
<tr class="memdesc:ga37e0195dbaf69283dd8541c2ae631b82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get socket options.  <a href="#ga37e0195dbaf69283dd8541c2ae631b82">More...</a><br /></td></tr>
<tr class="separator:ga37e0195dbaf69283dd8541c2ae631b82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad78fc85141d8c310b14d399f055823a6"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___b_s_d___socket.html#gad78fc85141d8c310b14d399f055823a6">recv</a> (int sd, void *pBuf, size_t Len, int flags)</td></tr>
<tr class="memdesc:gad78fc85141d8c310b14d399f055823a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data from TCP socket.  <a href="#gad78fc85141d8c310b14d399f055823a6">More...</a><br /></td></tr>
<tr class="separator:gad78fc85141d8c310b14d399f055823a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d0c3ce56a97523b4c46e9e28b6d1434"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___b_s_d___socket.html#ga8d0c3ce56a97523b4c46e9e28b6d1434">recvfrom</a> (int sd, void *buf, _i16 Len, _i16 flags, sockaddr *from, socklen_t *fromlen)</td></tr>
<tr class="memdesc:ga8d0c3ce56a97523b4c46e9e28b6d1434"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data from socket.  <a href="#ga8d0c3ce56a97523b4c46e9e28b6d1434">More...</a><br /></td></tr>
<tr class="separator:ga8d0c3ce56a97523b4c46e9e28b6d1434"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5292f928b7aca5f3c8b86e77a4a02b67"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___b_s_d___socket.html#ga5292f928b7aca5f3c8b86e77a4a02b67">send</a> (int sd, const void *pBuf, _i16 Len, _i16 flags)</td></tr>
<tr class="memdesc:ga5292f928b7aca5f3c8b86e77a4a02b67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data to TCP socket.  <a href="#ga5292f928b7aca5f3c8b86e77a4a02b67">More...</a><br /></td></tr>
<tr class="separator:ga5292f928b7aca5f3c8b86e77a4a02b67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c398c633b0f21a8ed43730d17030ba4"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___b_s_d___socket.html#ga7c398c633b0f21a8ed43730d17030ba4">sendto</a> (int sd, const void *pBuf, size_t Len, int flags, const sockaddr *to, socklen_t tolen)</td></tr>
<tr class="memdesc:ga7c398c633b0f21a8ed43730d17030ba4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data to socket.  <a href="#ga7c398c633b0f21a8ed43730d17030ba4">More...</a><br /></td></tr>
<tr class="separator:ga7c398c633b0f21a8ed43730d17030ba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga42431644cca2256f1058e3f5f4a5c5c4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga42431644cca2256f1058e3f5f4a5c5c4"></a>
char *&#160;</td><td class="memItemRight" valign="bottom"><b>h_name</b></td></tr>
<tr class="separator:ga42431644cca2256f1058e3f5f4a5c5c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae14b193c012a3358601fa608b369ea16"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae14b193c012a3358601fa608b369ea16"></a>
char **&#160;</td><td class="memItemRight" valign="bottom"><b>h_aliases</b></td></tr>
<tr class="separator:gae14b193c012a3358601fa608b369ea16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga913b2bbf34d26ed76f7109a7a17bf4a3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga913b2bbf34d26ed76f7109a7a17bf4a3"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>h_addrtype</b></td></tr>
<tr class="separator:ga913b2bbf34d26ed76f7109a7a17bf4a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5906b78ee4dffe8785c3d40de2e69f5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa5906b78ee4dffe8785c3d40de2e69f5"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>h_length</b></td></tr>
<tr class="separator:gaa5906b78ee4dffe8785c3d40de2e69f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga058204dad180c9850b3ffaf6b32f5b4c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga058204dad180c9850b3ffaf6b32f5b4c"></a>
char **&#160;</td><td class="memItemRight" valign="bottom"><b>h_addr_list</b></td></tr>
<tr class="separator:ga058204dad180c9850b3ffaf6b32f5b4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Controls standard client/server sockets programming options and capabilities. </p>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga9cd9fbec0dbb386f3ed5fce6c0bdb20a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int accept </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sockaddr *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">socklen_t *&#160;</td>
          <td class="paramname"><em>addrlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Accept a connection on a socket. </p>
<p>This function is used with connection-based socket types (SOCK_STREAM).<br />
It extracts the first connection request on the queue of pending connections, creates a new connected socket, and returns a new file descriptor referring to that socket.<br />
The newly created socket is not in the listening state. The original socket sd is unaffected by this call. <br />
The argument sd is a socket that has been created with <a class="el" href="group___b_s_d___socket.html#ga3069f151a5fd4a29e3f0dafe7af43ea8" title="Create an endpoint for communication. ">socket()</a>, bound to a local address with <a class="el" href="group___b_s_d___socket.html#ga203a2eda9a8c5a71d6056c67cae6aff5" title="Assign a name to a socket. ">bind()</a>, and is listening for connections after a <a class="el" href="group___b_s_d___socket.html#gac0e1e895317be91692b6b8cc7e12b252" title="Listen for connections on a socket. ">listen()</a>. The argument <b><em>addr</em> is</b> a pointer to a sockaddr structure. This structure is filled in with the address of the peer socket, as known to the communications layer. The exact format of the address returned addr is determined by the socket's address family. <br />
The <b><em>addrlen</em> argument</b> is a value-result argument: it should initially contain the size of the structure pointed to by addr, on return it will contain the actual length (in bytes) of the address returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sd</td><td>Socket descriptor (handle) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">addr</td><td>The argument addr is a pointer to a sockaddr structure. This structure is filled in with the address of the peer socket, as known to the communications layer. The exact format of the address returned addr is determined by the socket's address<br />
 sockaddr:<br />
 - code for the address format. On this version only AF_INET is supported.<br />
 - socket address, the length depends on the code format </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">addrlen</td><td>The addrlen argument is a value-result argument: it should initially contain the size of the structure pointed to by addr</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, a socket handle.<br />
 On a non-blocking accept a possible retrun is -1 and errno is set to EAGAIN.<br />
 On failure, errno is set and -1 is returned.<br />
 ENOMEM may be return in case there are no resources in the system In this case try again later or increase MAX_CONCURRENT_ACTIONS.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___b_s_d___socket.html#ga3069f151a5fd4a29e3f0dafe7af43ea8" title="Create an endpoint for communication. ">socket</a> <a class="el" href="group___b_s_d___socket.html#ga203a2eda9a8c5a71d6056c67cae6aff5" title="Assign a name to a socket. ">bind</a> <a class="el" href="group___b_s_d___socket.html#gac0e1e895317be91692b6b8cc7e12b252" title="Listen for connections on a socket. ">listen</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Belongs to server_side </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="ga203a2eda9a8c5a71d6056c67cae6aff5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bind </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sockaddr *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">socklen_t&#160;</td>
          <td class="paramname"><em>addrlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign a name to a socket. </p>
<p>This function gives the socket the local address addr. addr is addrlen bytes long. Traditionally, this is called When a socket is created with socket, it exists in a name space (address family) but has no name assigned. It is necessary to assign a local address before a SOCK_STREAM socket may receive connections.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sd</td><td>Socket descriptor (handle) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>Specifies the destination addrs<br />
 sockaddr:<br />
 - code for the address format. On this version only AF_INET is supported.<br />
 - socket address, the length depends on the code format. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addrlen</td><td>Contains the size of the structure pointed to by addr</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero on success, or -1 on failure and sets errno to the corresponding BDS error code.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___b_s_d___socket.html#ga3069f151a5fd4a29e3f0dafe7af43ea8" title="Create an endpoint for communication. ">socket</a> <a class="el" href="group___b_s_d___socket.html#ga9cd9fbec0dbb386f3ed5fce6c0bdb20a" title="Accept a connection on a socket. ">accept</a> <a class="el" href="group___b_s_d___socket.html#gac0e1e895317be91692b6b8cc7e12b252" title="Listen for connections on a socket. ">listen</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>belongs to basic_api </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="ga8548b5734b7684ed0a0f4b684ed726c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int connect </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sockaddr *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">socklen_t&#160;</td>
          <td class="paramname"><em>addrlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initiate a connection on a socket. </p>
<p>Function connects the socket referred to by the socket descriptor sd, to the address specified by addr. The addrlen argument specifies the size of addr. The format of the address in addr is determined by the address space of the socket. If it is of type SOCK_DGRAM, this call specifies the peer with which the socket is to be associated; this address is that to which datagrams are to be sent, and the only address from which datagrams are to be received. If the socket is of type SOCK_STREAM, this call attempts to make a connection to another socket. The other socket is specified by address, which is an address in the communications space of the socket.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sd</td><td>Socket descriptor (handle) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>Specifies the destination addr<br />
 sockaddr:<br />
 - code for the address format. On this version only AF_INET is supported.<br />
 - socket address, the length depends on the code format</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addrlen</td><td>Contains the size of the structure pointed to by addr</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, a socket handle.<br />
 On a non-blocking connect a possible negative value is EALREADY. On failure, -1 is returned and sets errno to the corresponding BDS error code.<br />
 ENOMEM may be return in case there are no resources in the system In this case try again later or increase MAX_CONCURRENT_ACTIONS</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___socket.html#gaa775fcb6d09bf35b9dac3e5eb8e8c997" title="Create an endpoint for communication. ">sl_Socket</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>belongs to BSD Socket </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="ga636674bf9937205b85a797ee6077faa9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structhostent.html">hostent</a>* gethostbyname </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get host IP by name<br />
Obtain the IP Address of machine on network, by machine name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">const</td><td>char *name Host name</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Struct hostent containing the answer on success or NULL failure.<br />
 </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___net_app.html#ga627fbeda3eea582e2f16de61d5d315f6" title="Get host IP by name Obtain the IP Address of machine on network, by machine name. ...">sl_NetAppDnsGetHostByName</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>Note: The function isn't reentrant! It utilize a static hostent struct which holds the answer for the DNS query. Calling this function form several threads may result in invalid answers. A user interested in a reentrant function which resolves IP address by name, can use the SimpleLink API: 'sl_NetAppDnsGetHostByName'. Another option is to protect this call with a lock and copy the returned hostent struct to a user buffer, before unlocking.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The parameter 'name' is assumed to be allocated by the user, and it's the user's Responsibility to maintain it's validity. This field is copied (not deep copied) to the struct returned by this function.</dd></dl>
<dl class="section user"><dt>Example</dt><dd></dd></dl>
<ul>
<li>Getting host by name: <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;int DestinationIP;</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;int AddrSize;</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;int SockId;</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;sockaddr_t Addr;</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;struct hostent DnsEntry;</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;DnsEntry = gethostbyname(&quot;www.google.com&quot;);</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;if(!DnsEntry)</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;{</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;    Addr.sin_family = AF_INET;</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;    Addr.sin_port = htons(80);</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;    Addr.sin_addr.s_addr = htonl(DestinationIP);</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;    AddrSize = sizeof(sockaddr_t);</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;    SockId = socket(AF_INET, SOCK_STREAM, 0);</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;}</div>
</div><!-- fragment --> </li>
</ul>

</div>
</div>
<a class="anchor" id="ga37e0195dbaf69283dd8541c2ae631b82"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getsockopt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>optname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>optval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">socklen_t *&#160;</td>
          <td class="paramname"><em>optlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get socket options. </p>
<p>This function manipulate the options associated with a socket. Options may exist at multiple protocol levels; they are always present at the uppermost socket level.<br />
 When manipulating socket options the level at which the option resides and the name of the option must be specified. To manipulate options at the socket level, level is specified as SOL_SOCKET. To manipulate options at any other level the protocol number of the appropriate proto- col controlling the option is supplied. For example, to indicate that an option is to be interpreted by the TCP protocol, level should be set to the protocol number of TCP; <br />
 The parameters optval and optlen are used to access optval - ues for <a class="el" href="group___b_s_d___socket.html#gaafa5721213ca1bfb2c1ab1ea0f39bf5c" title="Set socket options-. ">setsockopt()</a>. For <a class="el" href="group___b_s_d___socket.html#ga37e0195dbaf69283dd8541c2ae631b82" title="Get socket options. ">getsockopt()</a> they identify a buffer in which the value for the requested option(s) are to be returned. For <a class="el" href="group___b_s_d___socket.html#ga37e0195dbaf69283dd8541c2ae631b82" title="Get socket options. ">getsockopt()</a>, optlen is a value-result parameter, initially containing the size of the buffer pointed to by option_value, and modified on return to indicate the actual size of the value returned. If no option value is to be supplied or returned, option_value may be NULL.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sd</td><td>Socket handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>Defines the protocol level for this option </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">optname</td><td>defines the option name to interrogate </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">optval</td><td>Specifies a value for the option </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">optlen</td><td>Specifies the length of the option value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero on success, or -1 on failure and sets errno to the corresponding BDS error code. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___b_s_d___socket.html#gaafa5721213ca1bfb2c1ab1ea0f39bf5c" title="Set socket options-. ">setsockopt</a> Belongs to BSD <a class="el" href="group___socket.html" title="Controls standard client/server sockets programming options and capabilities. ">Socket</a> </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="gac0e1e895317be91692b6b8cc7e12b252"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int listen </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>backlog</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Listen for connections on a socket. </p>
<p>The willingness to accept incoming connections and a queue limit for incoming connections are specified with <a class="el" href="group___b_s_d___socket.html#gac0e1e895317be91692b6b8cc7e12b252" title="Listen for connections on a socket. ">listen()</a>, and then the connections are accepted with accept. The <a class="el" href="group___b_s_d___socket.html#gac0e1e895317be91692b6b8cc7e12b252" title="Listen for connections on a socket. ">listen()</a> call applies only to sockets of type SOCK_STREAM The backlog parameter defines the maximum length the queue of pending connections may grow to.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sd</td><td>Socket descriptor (handle) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">backlog</td><td>Specifies the listen queue depth.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero on success, or -1 on failure and sets errno to the corresponding BDS error code.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___b_s_d___socket.html#ga3069f151a5fd4a29e3f0dafe7af43ea8" title="Create an endpoint for communication. ">socket</a> <a class="el" href="group___b_s_d___socket.html#ga9cd9fbec0dbb386f3ed5fce6c0bdb20a" title="Accept a connection on a socket. ">accept</a> <a class="el" href="group___b_s_d___socket.html#ga203a2eda9a8c5a71d6056c67cae6aff5" title="Assign a name to a socket. ">bind</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Belongs to BSD Socket </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="gad78fc85141d8c310b14d399f055823a6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t recv </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read data from TCP socket. </p>
<p>Function receives a message from a connection-mode socket</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sd</td><td>Socket handle </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>Points to the buffer where the message should be stored. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Specifies the length in bytes of the buffer pointed to by the buffer argument. Range: 1-16000 bytes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Specifies the type of message reception. On this version, this parameter is not supported.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the number of bytes received, or a -1 if an error occurred. Errno is set accordingly.<br />
 Using a non-blocking recv a possible errno value is EAGAIN.<br />
 errno may be set to ENOMEM in case there are no resources in the system In this case try again later or increase MAX_CONCURRENT_ACTIONS</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___socket.html#ga02f8b2eb34db39069a1385d4fce80eea" title="Read data from socket. ">sl_RecvFrom</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Belongs to recv_api </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd></dd></dl>
<dl class="section user"><dt>Examples</dt><dd></dd></dl>
<ul>
<li>Receiving data using TCP socket: <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;sockaddr_in  Addr;</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;sockaddr_in  LocalAddr;</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;int AddrSize = sizeof(socklen_t);</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;int SockID, newSockID;</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;int Status;</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;char Buf[RECV_BUF_LEN];</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;LocalAddr.sin_family = AF_INET;</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;LocalAddr.sin_port = htons(5001);</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;LocalAddr.sin_addr.s_addr = 0;</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;Addr.sin_family = AF_INET;</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;Addr.sin_port = htons(5001);</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;Addr.sin_addr.s_addr = htonl(SL_IPV4_VAL(10,1,1,200));</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;SockID = socket(AF_INET, SOCK_STREAM, 0);</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;Status = bind(SockID, (sockaddr *)&amp;LocalAddr, AddrSize);</div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;Status = listen(SockID, 0);</div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;newSockID = accept(SockID, (sockaddr *)&amp;Addr, (socklen_t*) &amp;AddrSize);</div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;Status = recv(newSockID, Buf, 1460, 0);</div>
</div><!-- fragment --> <br />
 </li>
</ul>

</div>
</div>
<a class="anchor" id="ga8d0c3ce56a97523b4c46e9e28b6d1434"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t recvfrom </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_i16&#160;</td>
          <td class="paramname"><em>Len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_i16&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sockaddr *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">socklen_t *&#160;</td>
          <td class="paramname"><em>fromlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read data from socket. </p>
<p>Function receives a message from a connection-mode or connectionless-mode socket</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sd</td><td>Socket handle </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>Points to the buffer where the message should be stored. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Specifies the length in bytes of the buffer pointed to by the buffer argument. Range: 1-16000 bytes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Specifies the type of message reception. On this version, this parameter is not supported. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">from</td><td>Pointer to an address structure indicating the source address.<br />
 sockaddr:<br />
 - code for the address format. On this version only AF_INET is supported.<br />
 - socket address, the length depends on the code format </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fromlen</td><td>Source address structure size. This parameter MUST be set to the size of the structure pointed to by addr.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the number of bytes received, or a -1 if an error occurred. Errno is set accordingly.<br />
 Using a non-blocking recv a possible errno value is EAGAIN.<br />
 errno will be set to EINVAL if fromlen has incorrect length. <br />
 errno may be set to ENOMEM in case there are no resources in the system In this case try again later or increase MAX_CONCURRENT_ACTIONS</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___b_s_d___socket.html#gad78fc85141d8c310b14d399f055823a6" title="Read data from TCP socket. ">recv</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Belongs to BSD Socket </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd></dd></dl>
<dl class="section user"><dt>Example</dt><dd></dd></dl>
<ul>
<li>Receiving data: <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;sockaddr_in  Addr;</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;sockaddr_in  LocalAddr;</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;int AddrSize = sizeof(socklen_t);</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;int SockID, newSockID;</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;int Status;</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;char Buf[RECV_BUF_LEN];</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;LocalAddr.sin_family = AF_INET;</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;LocalAddr.sin_port = htons(5001);</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;LocalAddr.sin_addr.s_addr = 0;</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;SockID = socket(AF_INET, SOCK_STREAM, 0);</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;Status = bind(SockID, (sockaddr *)&amp;LocalAddr, AddrSize);</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;Status = recvfrom(SockID, Buf, 1472, 0, (sockaddr_in *)&amp;Addr, (socklen_t*)&amp;AddrSize); </div>
</div><!-- fragment --> </li>
</ul>

</div>
</div>
<a class="anchor" id="ga6802e61923c5dc7fc6b317e250bebf2c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int select </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nfds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fd_set *&#160;</td>
          <td class="paramname"><em>readsds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fd_set *&#160;</td>
          <td class="paramname"><em>writesds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fd_set *&#160;</td>
          <td class="paramname"><em>exceptsds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct timeval *&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Monitor socket activity. </p>
<p>Select allow a program to monitor multiple file descriptors, waiting until one or more of the file descriptors become "ready" for some class of I/O operation. If trigger mode is enabled the active fdset is the one that retreived in the first triggerd call. To enable the trigger mode, an handler must be statically registered to the slcb_SocketTriggerEventHandler (<a class="el" href="user_8h_source.html">user.h</a>)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nfds</td><td>The highest-numbered file descriptor in any of the three sets, plus 1. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">readsds</td><td>Socket descriptors list for read monitoring and accept monitoring </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">writesds</td><td>Socket descriptors list for connect monitoring only, write monitoring is not supported </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">exceptsds</td><td>Socket descriptors list for exception monitoring, not supported. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>Is an upper bound on the amount of time elapsed before <a class="el" href="group___b_s_d___socket.html#ga6802e61923c5dc7fc6b317e250bebf2c" title="Monitor socket activity. ">select()</a> returns. Null or above 0xffff seconds means infinity timeout. The minimum timeout is 10 milliseconds, less than 10 milliseconds will be set automatically to 10 milliseconds. Max microseconds supported is 0xfffc00. In trigger mode the timout fields must be set to zero.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, <a class="el" href="group___b_s_d___socket.html#ga6802e61923c5dc7fc6b317e250bebf2c" title="Monitor socket activity. ">select()</a> returns the number of file descriptors contained in the three returned descriptor sets (that is, the total number of bits that are set in readfds, writefds, exceptfds) which may be zero if the timeout expires before anything interesting happens.<br />
 On error, a negative value is returned. readsds - return the sockets on which Read request will return without delay with valid data.<br />
 writesds - return the sockets on which Write request will return without delay.<br />
 exceptsds - return the sockets closed recently. <br />
 ENOMEM may be return in case there are no resources in the system In this case try again later or increase MAX_CONCURRENT_ACTIONS</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___b_s_d___socket.html#ga3069f151a5fd4a29e3f0dafe7af43ea8" title="Create an endpoint for communication. ">socket</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If the timeout value set to less than 10ms it will automatically set to 10ms to prevent overload of the system<br />
 Belongs to BSD Socket</dd></dl>
<p>Only one select can be handled at a time.<b>Calling</b> this API while the same command is called from another thread, may result in one of the following scenarios:</p><ol type="1">
<li>The command will wait (internal) until the previous command finish, and then be executed.</li>
<li>There are not enough resources and ENOMEM error will return. In this case, MAX_CONCURRENT_ACTIONS can be increased (result in memory increase) or try again later to issue the command.</li>
<li>In case there is already a triggered sl_Select in progress, the following call will return with SL_RET_CODE_SOCKET_SELECT_IN_PROGRESS_ERROR.</li>
</ol>
<dl class="section warning"><dt>Warning</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="ga5292f928b7aca5f3c8b86e77a4a02b67"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t send </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_i16&#160;</td>
          <td class="paramname"><em>Len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_i16&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write data to TCP socket. </p>
<p>This function is used to transmit a message to another socket. Returns immediately after sending data to device. In case of TCP failure an async event SL_SOCKET_TX_FAILED_EVENT is going to be received.<br />
 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sd</td><td>Socket handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>Points to a buffer containing the message to be sent </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Message size in bytes. Range: 1-1460 bytes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Specifies the type of message transmission. On this version, this parameter is not supported for TCP.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero on success, or -1 on failure and sets errno to the corresponding BDS error code.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___socket.html#ga7ca76d181974c71673c3bf3fc1fedfdc" title="Write data to socket. ">sl_SendTo</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Belongs to BSD Socket </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd></dd></dl>
<dl class="section user"><dt>Example</dt><dd></dd></dl>
<ul>
<li>Sending data: <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;sockaddr_in  Addr;</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;int AddrSize = sizeof(socklen_t);</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;int SockID;</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;int Status;</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;char Buf[SEND_BUF_LEN];</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;Addr.sin_family = AF_INET;</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;Addr.sin_port = htons(5001);</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;Addr.sin_addr.s_addr = htonl(SL_IPV4_VAL(10,1,1,200));</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;SockID = socket(AF_INET, SOCK_STREAM, 0);</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;Status = connect(SockID, (sockaddr_in*)&amp;Addr, AddrSize);</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;Status = send(SockID, Buf, 1460, 0 );</div>
</div><!-- fragment --> </li>
</ul>

</div>
</div>
<a class="anchor" id="ga7c398c633b0f21a8ed43730d17030ba4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t sendto </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sockaddr *&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">socklen_t&#160;</td>
          <td class="paramname"><em>tolen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write data to socket. </p>
<p>This function is used to transmit a message to another socket (connection less socket SOCK_DGRAM, SOCK_RAW).<br />
Returns immediately after sending data to device.<br />
In case of transmission failure an async event SL_SOCKET_TX_FAILED_EVENT is going to be received.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sd</td><td>Socket handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>Points to a buffer containing the message to be sent </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>message size in bytes. Range: 1-1460 bytes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Specifies the type of message transmission. On this version, this parameter is not supported </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">to</td><td>Pointer to an address structure indicating the destination address.<br />
 sockaddr:<br />
 - code for the address format. On this version only AF_INET is supported.<br />
 - socket address, the length depends on the code format </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tolen</td><td>Destination address structure size</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero on success, or -1 on failure and sets errno to the corresponding BDS error code.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___socket.html#ga2fc8c293bbcb796217076329e1bac518" title="Write data to TCP socket. ">sl_Send</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Belongs to BSD Socket </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd></dd></dl>
<dl class="section user"><dt>Example</dt><dd></dd></dl>
<ul>
<li>Sending data: <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;sockaddr_in  Addr;</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;int AddrSize = sizeof(socklen_t);</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;int SockID;</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;int Status;</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;char Buf[SEND_BUF_LEN];</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;Addr.sin_family = AF_INET;</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;Addr.sin_port = htons(5001);</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;Addr.sin_addr.s_addr = htonl(SL_IPV4_VAL(10,1,1,200));</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;SockID = socket(AF_INET, SOCK_DGRAM, 0);</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;Status = sendto(SockID, Buf, 1472, 0, (sockaddr_in *)&amp;Addr, AddrSize);</div>
</div><!-- fragment --> </li>
</ul>

</div>
</div>
<a class="anchor" id="gaafa5721213ca1bfb2c1ab1ea0f39bf5c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int setsockopt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>optname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>optval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">socklen_t&#160;</td>
          <td class="paramname"><em>optlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set socket options-. </p>
<p>This function manipulate the options associated with a socket.<br />
Options may exist at multiple protocol levels; they are always present at the uppermost socket level.<br />
 When manipulating socket options the level at which the option resides and the name of the option must be specified. To manipulate options at the socket level, level is specified as SOL_SOCKET. To manipulate options at any other level the protocol number of the appropriate proto- col controlling the option is supplied. For example, to indicate that an option is to be interpreted by the TCP protocol, level should be set to the protocol number of TCP; <br />
 The parameters optval and optlen are used to access optval - ues for <a class="el" href="group___b_s_d___socket.html#gaafa5721213ca1bfb2c1ab1ea0f39bf5c" title="Set socket options-. ">setsockopt()</a>. For <a class="el" href="group___b_s_d___socket.html#ga37e0195dbaf69283dd8541c2ae631b82" title="Get socket options. ">getsockopt()</a> they identify a buffer in which the value for the requested option(s) are to be returned. For <a class="el" href="group___b_s_d___socket.html#ga37e0195dbaf69283dd8541c2ae631b82" title="Get socket options. ">getsockopt()</a>, optlen is a value-result parameter, initially containing the size of the buffer pointed to by option_value, and modified on return to indicate the actual size of the value returned. If no option value is to be supplied or returned, option_value may be NULL.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sd</td><td>Socket handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>Defines the protocol level for this option<ul>
<li><b>SOL_SOCKET</b> Socket level configurations (L4, transport layer)</li>
<li><b>IPPROTO_IP</b> IP level configurations (L3, network layer) </li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">optname</td><td>Defines the option name to interrogate<ul>
<li><b>SOL_SOCKET</b></li>
<li><b>SO_KEEPALIVE</b> <br />
 Enable/Disable periodic keep alive. Keeps TCP connections active by enabling the periodic transmission of messages <br />
 Timeout is 5 minutes.<br />
 Default: Enabled <br />
 This options takes <a class="el" href="group___socket.html#struct_sl_sock_keepalive__t">SlSockKeepalive_t</a> struct as parameter<ul>
<li><b>SO_KEEPALIVETIME</b> <br />
 Set keep alive timeout. Value is in seconds <br />
 Default: 5 minutes <br />
</li>
<li><b>SO_RX_NO_IP_BOUNDARY</b> <br />
 Enable/Disable rx ip boundary. In connectionless socket (udp/raw), unread data is dropped (when recvfrom len parameter &lt; data size), Enable this option in order to read the left data on the next recvfrom iteration Default: Disabled, IP boundary kept, <br />
 This options takes <a class="el" href="group___socket.html#struct_sl_sock_rx_no_ip_boundary__t">SlSockRxNoIpBoundary_t</a> struct as parameter</li>
<li><b>SO_RCVTIMEO</b> <br />
 Sets the timeout value that specifies the maximum amount of time an input function waits until it completes. <br />
 Default: No timeout <br />
 This options takes <a class="el" href="group___socket.html#struct_sl_timeval__t">SlTimeval_t</a> struct as parameter</li>
<li><b>SO_RCVBUF</b> <br />
 Sets tcp max recv window size. <br />
 This options takes <a class="el" href="group___socket.html#struct_sl_sock_winsize__t">SlSockWinsize_t</a> struct as parameter</li>
<li><b>SO_NONBLOCKING</b> <br />
 Sets socket to non-blocking operation Impacts: connect, accept, send, sendto, recv and recvfrom. <br />
 Default: Blocking. This options takes <a class="el" href="group___socket.html#struct_sl_sock_nonblocking__t">SlSockNonblocking_t</a> struct as parameter</li>
</ul>
</li>
<li><b>IPPROTO_IP</b><ul>
<li><b>IP_MULTICAST_TTL</b> <br />
 Set the time-to-live value of outgoing multicast packets for this socket. <br />
 This options takes <b>_u8</b> as parameter</li>
<li><b>IP_ADD_MEMBERSHIP</b> <br />
 UDP socket, Join a multicast group. <br />
 This options takes <a class="el" href="group___socket.html#struct_sl_sock_ip_mreq__t">SlSockIpMreq_t</a> struct as parameter</li>
<li><b>IP_DROP_MEMBERSHIP</b> <br />
 UDP socket, Leave a multicast group <br />
 This options takes <a class="el" href="group___socket.html#struct_sl_sock_ip_mreq__t">SlSockIpMreq_t</a> struct as parameter</li>
<li><b>SO_LINGER</b> <br />
 Socket lingers on close pending remaining send/receive packetst<br />
</li>
</ul>
</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">optval</td><td>Specifies a value for the option </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">optlen</td><td>Specifies the length of the option value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero on success, or -1 on failure and sets errno to the corresponding BDS error code.</dd></dl>
<dl class="section user"><dt>Persistent </dt><dd>All params are <b>Non- Persistent</b> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___b_s_d___socket.html#ga37e0195dbaf69283dd8541c2ae631b82" title="Get socket options. ">getsockopt</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Belongs to basic_api </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="ga3069f151a5fd4a29e3f0dafe7af43ea8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int socket </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Protocol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an endpoint for communication. </p>
<p>The socket function creates a new socket of a certain socket type, identified by an integer number, and allocates system resources to it.<br />
This function is called by the application layer to obtain a socket handle.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Domain</td><td>Specifies the protocol family of the created socket. For example:<ul>
<li>AF_INET for network protocol IPv4</li>
<li>AF_INET6 for network protocol IPv6</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Type</td><td>specifies the communication semantic, one of:<ul>
<li>SOCK_STREAM (reliable stream-oriented service or Stream Sockets)</li>
<li>SOCK_DGRAM (datagram service or Datagram Sockets)</li>
<li>SOCK_RAW (raw protocols atop the network layer)</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Protocol</td><td>specifies a particular transport to be used with the socket. <br />
 The most common are<ul>
<li>IPPROTO_TCP</li>
<li>IPPROTO_UDP The value 0 may be used to select a default protocol from the selected domain and type</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, socket handle that is used for consequent socket operations. <br />
 A successful return code should be a positive number (int16)<br />
 On error, a negative (int16) value will be returned specifying the error code.<ul>
<li>EAFNOSUPPORT - illegal domain parameter</li>
<li>EPROTOTYPE - illegal type parameter</li>
<li>EACCES - permission denied</li>
<li>ENSOCK - exceeded maximal number of socket</li>
<li>ENOMEM - memory allocation error</li>
<li>EINVAL - error in socket configuration</li>
<li>EPROTONOSUPPORT - illegal protocol parameter</li>
<li>EOPNOTSUPP - illegal combination of protocol and type parameters</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd>close </dd></dl>
<dl class="section note"><dt>Note</dt><dd>belongs to basic_api </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd></dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="ga058204dad180c9850b3ffaf6b32f5b4c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char** h_addr_list</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="netdb_8h_source.html#l00036">36</a> of file <a class="el" href="netdb_8h_source.html">netdb.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga913b2bbf34d26ed76f7109a7a17bf4a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int h_addrtype</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="netdb_8h_source.html#l00034">34</a> of file <a class="el" href="netdb_8h_source.html">netdb.h</a>.</p>

</div>
</div>
<a class="anchor" id="gae14b193c012a3358601fa608b369ea16"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char** h_aliases</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="netdb_8h_source.html#l00033">33</a> of file <a class="el" href="netdb_8h_source.html">netdb.h</a>.</p>

</div>
</div>
<a class="anchor" id="gaa5906b78ee4dffe8785c3d40de2e69f5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int h_length</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="netdb_8h_source.html#l00035">35</a> of file <a class="el" href="netdb_8h_source.html">netdb.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga42431644cca2256f1058e3f5f4a5c5c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* h_name</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="netdb_8h_source.html#l00032">32</a> of file <a class="el" href="netdb_8h_source.html">netdb.h</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.10 </li>
  </ul>
</div>
</body>
</html>
